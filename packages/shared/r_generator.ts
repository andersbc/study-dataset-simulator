import {
  type StudyDesign,
  DIST_NORMAL,
  DIST_UNIFORM,
} from './mod.ts';


export function generateRScript(design: StudyDesign, n: number = 100): string {
  const lines: string[] = [];

  // 1. Header & Setup
  lines.push(`# Generated by Study Dataset Simulator`);
  lines.push(`# ${new Date().toISOString()}`);
  lines.push(``);
  lines.push(`# Check for simstudy package`);
  lines.push(`.libPaths(c("~/R/library", .libPaths()))`);
  lines.push(`if (!require("simstudy", quietly = TRUE)) {`);
  lines.push(`  stop("Package 'simstudy' is required but not installed.")`);
  lines.push(`}`);
  lines.push(`if (!require("data.table", quietly = TRUE)) {`);
  lines.push(`  stop("Package 'data.table' is required but not installed.")`);
  lines.push(`}`);
  lines.push(``);
  lines.push(`# Set seed for reproducibility`);
  lines.push(`set.seed(1234)`);
  lines.push(``);
  lines.push(`# Set sample size`);
  lines.push(`n_obs <- ${n}`);
  lines.push(``);
  lines.push(`# --- Data Definition ---`);
  lines.push(``);

  if (!design.variables || design.variables.length === 0) {
    lines.push(`# No variables defined`);
    lines.push(`dd <- genData(${n})`);
    return finalizeScript(lines, false);
  }

  // 2. Flatten Definitions
  // We need to treat Variables and Instrument Items as individual "nodes" for simulation.
  interface SimNode {
    name: string;
    // deno-lint-ignore no-explicit-any
    distribution: any;
    categories?: string[];
    // For debugging/comments
    sourceGroup?: string;
  }

  const nodes: SimNode[] = [];
  const nameToNode = new Map<string, SimNode>();

  design.variables.forEach(v => {
    if (v.kind === 'variable') {
      const categories = 'categories' in v ? v.categories : undefined;
      const node = { name: v.name, distribution: v.distribution, categories, sourceGroup: 'Variable' };
      nodes.push(node);
      nameToNode.set(v.name, node);
    } else if (v.kind === 'instrument' && v.items) {
      v.items.forEach(item => {
        // Items inherit distribution from the Instrument, usually
        const node = {
          name: item.name,
          distribution: v.distribution,
          categories: v.categories,
          sourceGroup: `Instrument: ${v.name}`
        };
        nodes.push(node);
        nameToNode.set(item.name, node);
      });
    }
  });

  // 3. Build Dependency Graph
  // Target -> Dependencies[]
  const dependencies = new Map<string, string[]>();
  // Target -> Effects[]
  const nodeEffects = new Map<string, typeof design.effects>();

  if (design.effects) {
    design.effects.forEach(eff => {
      // Add dependency
      const deps = dependencies.get(eff.target) || [];
      if (!deps.includes(eff.source)) {
        deps.push(eff.source);
        dependencies.set(eff.target, deps);
      }

      // Store effect for formula generation
      const effs = nodeEffects.get(eff.target) || [];
      effs.push(eff);
      nodeEffects.set(eff.target, effs);
    });
  }

  // 4. Topological Sort
  // Kahn's algorithm or DFS
  const sortedNodes: SimNode[] = [];
  const visited = new Set<string>();
  const tempVisited = new Set<string>();

  const visit = (name: string) => {
    if (tempVisited.has(name)) {
      // Cycle detected! Ignore for now or handle gracefully?
      // We'll just break the cycle by returning.
      return;
    }
    if (visited.has(name)) return;

    tempVisited.add(name);

    const deps = dependencies.get(name) || [];
    deps.forEach(depName => {
      // Only visit if the dependency actually exists in our nodes
      // (User might have deleted a variable but effect remains?)
      if (nameToNode.has(depName)) {
        visit(depName);
      }
    });

    tempVisited.delete(name);
    visited.add(name);

    // Safety check: existing node
    const node = nameToNode.get(name);
    if (node) sortedNodes.push(node);
  };

  // Iterate all nodes to ensure disconnected components are included
  nodes.forEach(node => {
    if (!visited.has(node.name)) {
      visit(node.name);
    }
  });

  // 5. Generate Code
  const generatedVariables = new Set<string>();

  sortedNodes.forEach((node, index) => {
    const isFirst = index === 0;
    const defObj = isFirst ? 'NULL' : 'def';

    // Base Formula and Distortion
    let formula = "0";
    let distType = "normal"; // default
    let distArgs = ""; // e.g. variance = ...

    const dist = node.distribution;
    const effects = nodeEffects.get(node.name) || [];

    // Smart Intercept & Variance Calculation
    let parentShift = 0;
    let effectFormula = "";
    let explainedVariance = 0;

    if (effects.length > 0) {
      effectFormula = effects
        .filter(e => generatedVariables.has(e.source))
        .map(e => {
          let coeff = e.coefficient ?? 0;

          const parentNode = nameToNode.get(e.source);

          // If the effect is defined as a 'correlation', we need to convert it to a regression coefficient
          // Beta = Correlation * (SD_y / SD_x)
          if (e.type === 'correlation' && dist.type === DIST_NORMAL && parentNode && parentNode.distribution.type === DIST_NORMAL) {
            const sdY = dist.stdDev ?? 1;
            const sdX = parentNode.distribution.stdDev ?? 1;
            if (sdX !== 0) {
              coeff = coeff * (sdY / sdX);
            }
          }

          // Calculate shift if we can resolve the parent structure
          if (parentNode && parentNode.distribution.type === DIST_NORMAL) {
            const pMean = parentNode.distribution.mean ?? 0;
            const pSd = parentNode.distribution.stdDev ?? 1;

            parentShift += (coeff * pMean);

            // Assume independent parents for now (sum of variances)
            // explainedVar = beta^2 * var(X)
            explainedVariance += (coeff * coeff) * (pSd * pSd);
          }

          return ` + ${coeff} * ${e.source}`;
        }).join("");
    }

    if (dist.type === DIST_NORMAL) {
      const targetMean = dist.mean ?? 0;
      // Adjust intercept so that Expected Value = targetMean
      // Intercept = TargetMean - ParentShift
      const intercept = targetMean - parentShift;

      const totalVariance = Math.pow(dist.stdDev ?? 1, 2);
      let residualVariance = totalVariance - explainedVariance;

      // Safety: Variance cannot be negative. This happens if correlations are too strong (R^2 > 1).
      if (residualVariance < 0) residualVariance = 0;

      // Combined formula
      formula = `"${intercept}${effectFormula}"`;
      distType = "normal";
      distArgs = `, variance = ${residualVariance}`;
    }
    else if (dist.type === DIST_UNIFORM) {
      if ('min' in dist) {
        const min = dist.min ?? 0;
        const max = dist.max ?? 10;
        formula = `"${min};${max}"`;
        distType = "uniform";
      } else {
        // Categorical/Binary default
        if (node.categories && node.categories.length > 0) {
          const prob = (1 / node.categories.length).toFixed(4);
          formula = `"${node.categories.map(() => prob).join(';')}"`;
          distType = "categorical";
        } else {
          formula = "0.5";
          distType = "binary";
        }
      }
    }

    lines.push(`def <- defData(${defObj}, varname = "${node.name}", formula = ${formula}${distArgs}, dist = "${distType}")`);
    generatedVariables.add(node.name);
  });

  lines.push(``);
  lines.push(`# --- Generation ---`);
  lines.push(`dd <- genData(n_obs, def)`);

  // Reorder columns to match design order
  if (nodes.length > 0) {
    const colOrder = nodes.map(n => `"${n.name}"`).join(', ');
    lines.push(``);
    lines.push(`# --- Reorder Columns ---`);
    lines.push(`# Ensure output order matches design order (keeping 'id' first)`);
    lines.push(`if ("id" %in% names(dd)) {`);
    lines.push(`  setcolorder(dd, c("id", ${colOrder}))`);
    lines.push(`} else {`);
    lines.push(`  setcolorder(dd, c(${colOrder}))`);
    lines.push(`}`);
  }

  return finalizeScript(lines, true);
}

function finalizeScript(lines: string[], hasVars: boolean): string {
  if (hasVars) {
    // nothing extra
  }
  lines.push(``);
  lines.push(`# --- Output ---`);
  lines.push(`write.csv(dd, stdout(), row.names=FALSE, quote=FALSE)`);
  return lines.join('\n');
}
