import {
  type StudyDesign,
  DIST_NORMAL,
  DIST_UNIFORM,
} from './mod.ts';


import { R_GENERATOR_LOGIC } from "./r_logic.gen.ts";

export function generateRScript(design: StudyDesign, n: number = 100): string {
  const lines: string[] = [];

  // --- Header ---
  lines.push(`# Generated by Study Dataset Simulator`);
  lines.push(`# ${new Date().toISOString()}`);
  lines.push(``);
  lines.push(`# --- Libraries ---`);
  lines.push(`.libPaths(c("~/R/library", .libPaths()))`);
  lines.push(`if (!require("simstudy", quietly = TRUE)) stop("Package 'simstudy' is required.")`);
  lines.push(`if (!require("data.table", quietly = TRUE)) stop("Package 'data.table' is required.")`);
  lines.push(``);
  lines.push(`set.seed(1234)`);
  lines.push(`n_obs <- ${n}`);
  lines.push(``);

  if (!design.variables || design.variables.length === 0) {
    lines.push(`# No variables defined`);
    lines.push(`dd <- genData(n_obs)`);
    lines.push(`write.csv(dd, stdout(), row.names=FALSE, quote=FALSE)`);
    return lines.join('\n');
  }

  // --- 1. Serialize Design to R List ---
  // We still do sorting in TS to ensure we define the list in dependency order (useful for config readability)
  // although the R function could technically hunt for parents, linear order is safer for simstudy.
  const nodes = flattenNodes(design);
  const nameToNode = new Map(nodes.map(n => [n.name, n]));
  const { dependencies, nodeEffects } = buildDependencyGraph(design);
  const sortedNodes = sortNodes(nodes, dependencies, nameToNode);

  lines.push(`# --- Study Configuration ---`);
  lines.push(`study_design <- list(`);

  const uiOrderMap = new Map(nodes.map((n, i) => [n.name, i + 1]));

  const configItems = sortedNodes.map(node => {
    const parts: string[] = [`name = "${node.name}"`];
    parts.push(`order = ${uiOrderMap.get(node.name)}`);

    // Distribution
    if (node.categories && node.categories.length > 0) {
      parts.push(`type = "categorical"`);
      const probs = new Array(node.categories.length).fill(1 / node.categories.length);
      parts.push(`probs = c(${probs.map(p => p.toFixed(4)).join(', ')})`);
      const labels = node.categories.map(c => `"${c}"`).join(', ');
      parts.push(`labels = c(${labels})`);
    } else if (node.distribution.type === 'normal') {
      parts.push(`type = "normal"`);
      parts.push(`mean = ${node.distribution.mean ?? 0}`);
      parts.push(`sd = ${node.distribution.stdDev ?? 1}`);
    } else if (node.distribution.type === 'uniform') {
      parts.push(`type = "uniform"`);
      parts.push(`min = ${node.distribution.min ?? 0}`);
      parts.push(`max = ${node.distribution.max ?? 0}`);
    } else {
      // Fallback
      parts.push(`type = "normal"`);
      parts.push(`mean = 0`);
      parts.push(`sd = 1`);
    }

    // Effects / Parents
    const effects = nodeEffects.get(node.name) || [];
    if (effects.length > 0) {
      const fxList = effects.map(eff => {
        return `list(source = "${eff.source}", coef = ${eff.coefficient}, type = "${eff.type}")`;
      }).join(',\n      ');
      parts.push(`parents = list(\n      ${fxList}\n    )`);
    } else {
      parts.push(`parents = list()`);
    }

    return `  list(\n    ${parts.join(',\n    ')}\n  )`;
  });

  lines.push(configItems.join(',\n'));
  lines.push(`)`);
  lines.push(``);

  // --- 2. R Logic Function ---
  lines.push(R_GENERATOR_LOGIC);
  lines.push(``);
  lines.push(`# --- Execution ---`);

  lines.push(`dd <- generate_study(n_obs, study_design)`);

  lines.push(``);
  lines.push(`write.csv(dd, stdout(), row.names=FALSE, quote=FALSE)`);

  return lines.join('\n');
}


// --- Helper Types & Functions ---

export interface SimNode {
  name: string;
  // deno-lint-ignore no-explicit-any
  distribution: any;
  categories?: string[];
  sourceGroup?: string;
}

export function flattenNodes(design: StudyDesign): SimNode[] {
  const nodes: SimNode[] = [];
  if (!design.variables) return nodes;

  design.variables.forEach(v => {
    if (v.kind === 'variable') {
      const categories = 'categories' in v ? v.categories : undefined;
      nodes.push({ name: v.name, distribution: v.distribution, categories, sourceGroup: 'Variable' });
    } else if (v.kind === 'instrument' && v.items) {
      v.items.forEach(item => {
        nodes.push({
          name: item.name,
          distribution: v.distribution,
          categories: v.categories,
          sourceGroup: `Instrument: ${v.name}`
        });
      });
    }
  });
  return nodes;
}

export function buildDependencyGraph(design: StudyDesign) {
  const dependencies = new Map<string, string[]>();
  const nodeEffects = new Map<string, typeof design.effects>();

  if (design.effects) {
    design.effects.forEach(eff => {
      const deps = dependencies.get(eff.target) || [];
      if (!deps.includes(eff.source)) {
        deps.push(eff.source);
        dependencies.set(eff.target, deps);
      }

      const effs = nodeEffects.get(eff.target) || [];
      effs.push(eff);
      nodeEffects.set(eff.target, effs);
    });
  }
  return { dependencies, nodeEffects };
}

export function sortNodes(nodes: SimNode[], dependencies: Map<string, string[]>, nameToNode: Map<string, SimNode>): SimNode[] {
  const sortedNodes: SimNode[] = [];
  const visited = new Set<string>();
  const tempVisited = new Set<string>();

  const visit = (name: string) => {
    if (tempVisited.has(name)) return; // Cycle detected
    if (visited.has(name)) return;

    tempVisited.add(name);

    const deps = dependencies.get(name) || [];
    deps.forEach(depName => {
      if (nameToNode.has(depName)) {
        visit(depName);
      }
    });

    tempVisited.delete(name);
    visited.add(name);

    const node = nameToNode.get(name);
    if (node) sortedNodes.push(node);
  };

  nodes.forEach(node => {
    if (!visited.has(node.name)) visit(node.name);
  });

  return sortedNodes;
}
